
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>2.1. tnpy.operators.MatrixProductOperator &#8212; tnpy 0.1.1a3 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2.2. tnpy.operators.SpinOperators" href="tnpy.operators.SpinOperators.html" />
    <link rel="prev" title="2. Matrix Product Operator (MPO) &amp; others" href="../operators.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">tnpy 0.1.1a3 documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Algorithms
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../algorithm/exact_diagonalization.html">
   1. Exact Diagonalization (ED)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/_autosummary/tnpy.exact_diagonalization.ExactDiagonalization.html">
     1.1. tnpy.exact_diagonalization.ExactDiagonalization
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../algorithm/finite_dmrg.html">
   2. Finite Density Matrix Renormalization Group (fDMRG)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/_autosummary/tnpy.finite_dmrg.FiniteDMRG.html">
     2.1. tnpy.finite_dmrg.FiniteDMRG
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/_autosummary/tnpy.finite_dmrg.ShiftInvertDMRG.html">
     2.2. tnpy.finite_dmrg.ShiftInvertDMRG
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../algorithm/finite_tdvp.html">
   3. Finite Time-dependent Variational Principle (fTDVP)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/_autosummary/tnpy.finite_tdvp.FiniteTDVP.html">
     3.1. tnpy.finite_tdvp.FiniteTDVP
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../algorithm/tsdrg.html">
   4. Tree Tensor Strong-disorder Renormalization Group (tSDRG)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/_autosummary/tnpy.tsdrg.Node.html">
     4.1. tnpy.tsdrg.Node
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/_autosummary/tnpy.tsdrg.TensorTree.html">
     4.2. tnpy.tsdrg.TensorTree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/_autosummary/tnpy.tsdrg.TreeTensorNetworkSDRG.html">
     4.3. tnpy.tsdrg.TreeTensorNetworkSDRG
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/_autosummary/tnpy.tsdrg.TreeTensorNetworkMeasurements.html">
     4.4. tnpy.tsdrg.TreeTensorNetworkMeasurements
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/_autosummary/tnpy.tsdrg.HighEnergyTreeTensorNetworkSDRG.html">
     4.5. tnpy.tsdrg.HighEnergyTreeTensorNetworkSDRG
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../algorithm/_autosummary/tnpy.tsdrg.ShiftInvertTreeTensorNetworkSDRG.html">
     4.6. tnpy.tsdrg.ShiftInvertTreeTensorNetworkSDRG
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../notebooks/tsdrg.html">
     4.7.1. Algorithm
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Built-in models
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../model/model_1d.html">
   1. Model 1D
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../model/_autosummary/tnpy.model.Model1D.html">
     1.1. tnpy.model.Model1D
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../model/xxz.html">
   2. XXZ model
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../model/_autosummary/tnpy.model.XXZ.html">
     2.1. tnpy.model.XXZ
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../model/dimer_xxz.html">
   3. Dimer XXZ model
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../model/_autosummary/tnpy.model.DimerXXZ.html">
     3.1. tnpy.model.DimerXXZ
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../model/random_heisenberg.html">
   4. Random Heisenberg model
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../model/_autosummary/tnpy.model.RandomHeisenberg.html">
     4.1. tnpy.model.RandomHeisenberg
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../model/thirring.html">
   5. Thirring model
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../model/_autosummary/tnpy.model.Thirring.html">
     5.1. tnpy.model.Thirring
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../model/total_sz.html">
   6. Total Sz
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../model/_autosummary/tnpy.model.TotalSz.html">
     6.1. tnpy.model.TotalSz
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../model/utils.html">
   7. Utils
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
  <label for="toctree-checkbox-11">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../model/_autosummary/tnpy.model.utils.html">
     7.1. tnpy.model.utils
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Operators and linear algebra
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../matrix_product_state.html">
   1. Matrix Product State (MPS)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
  <label for="toctree-checkbox-12">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="tnpy.matrix_product_state.Direction.html">
     1.1. tnpy.matrix_product_state.Direction
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tnpy.matrix_product_state.MatrixProductState.html">
     1.2. tnpy.matrix_product_state.MatrixProductState
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tnpy.matrix_product_state.Environment.html">
     1.3. tnpy.matrix_product_state.Environment
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tnpy.matrix_product_state.MatrixProductStateMeasurements.html">
     1.4. tnpy.matrix_product_state.MatrixProductStateMeasurements
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="../operators.html">
   2. Matrix Product Operator (MPO) &amp; others
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
  <label for="toctree-checkbox-13">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     2.1. tnpy.operators.MatrixProductOperator
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tnpy.operators.SpinOperators.html">
     2.2. tnpy.operators.SpinOperators
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tnpy.operators.FullHamiltonian.html">
     2.3. tnpy.operators.FullHamiltonian
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../linalg.html">
   3. Linear Algebra
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/>
  <label for="toctree-checkbox-14">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="tnpy.linalg.html">
     3.1. tnpy.linalg
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/tanlin2013/tnpy"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/tanlin2013/tnpy/issues/new?title=Issue%20on%20page%20%2F_autosummary/tnpy.operators.MatrixProductOperator.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/tanlin2013/tnpy/edit/master/docs/_autosummary/tnpy.operators.MatrixProductOperator.rst"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Edit this page"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="headerbtn__text-container">suggest edit</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>tnpy.operators.MatrixProductOperator</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section id="tnpy-operators-matrixproductoperator">
<h1><span class="section-number">2.1. </span>tnpy.operators.MatrixProductOperator<a class="headerlink" href="#tnpy-operators-matrixproductoperator" title="Permalink to this headline">#</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="tnpy.operators.MatrixProductOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tnpy.operators.</span></span><span class="sig-name descname"><span class="pre">MatrixProductOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tnpy/operators.html#MatrixProductOperator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tnpy.operators.MatrixProductOperator" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">quimb.tensor.tensor_1d.MatrixProductOperator</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="tnpy.operators.MatrixProductOperator.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tnpy/operators.html#MatrixProductOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tnpy.operators.MatrixProductOperator.__init__" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<p class="rubric">Methods</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#id0" title="tnpy.operators.MatrixProductOperator.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(*args, **kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code>(t[, virtual, check_collisions])</p></td>
<td><p>Add Tensor, TensorNetwork or sequence thereof to self.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_MPO</span></code>(other[, inplace, compress])</p></td>
<td><p>Add another MatrixProductState to this one.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_MPO_</span></code>(other, *[, inplace, compress])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_tag</span></code>(tag[, where, which])</p></td>
<td><p>Add tag to every tensor in this network, or if <code class="docutils literal notranslate"><span class="pre">where</span></code> is specified, the tensors matching those tags -- i.e. adds the tag to all tensors in <code class="docutils literal notranslate"><span class="pre">self.select_tensors(where,</span> <span class="pre">which=which)</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_tensor</span></code>(tensor[, tid, virtual])</p></td>
<td><p>Add a single tensor to this network - mangle its tid if neccessary.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_tensor_network</span></code>(tn[, virtual, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">align</span></code>(*[, ind_ids, trace, inplace])</p></td>
<td><p>Align an arbitrary number of tensor networks in a stack-like geometry.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">align_</span></code>(*[, ind_ids, trace, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_inds</span></code>()</p></td>
<td><p>Return a tuple of all indices in this network.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">amplitude</span></code>(b)</p></td>
<td><p>Compute the amplitude of configuration <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">antidiag_gauge</span></code>([output_inds, atol, cache, ...])</p></td>
<td><p>Flip the order of any bonds connected to antidiagonal tensors.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">antidiag_gauge_</span></code>([output_inds, atol, cache, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply</span></code>(other[, compress])</p></td>
<td><p>Act with this MPO on another MPO or MPS, such that the resulting object has the same tensor network structure/indices as <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_to_arrays</span></code>(fn)</p></td>
<td><p>Modify every tensor's array inplace by applying <code class="docutils literal notranslate"><span class="pre">fn</span></code> to it.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_cyclic</span></code>([inplace])</p></td>
<td><p>Convert this flat, 1D, TN into cyclic form by adding a dummy bond between the first and last sites.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_network</span></code>([virtual])</p></td>
<td><p>Matching method (for ensuring object is a tensor network) to <code class="xref py py-meth docutils literal notranslate"><span class="pre">as_network()</span></code>, which simply returns <code class="docutils literal notranslate"><span class="pre">self</span></code> if <code class="docutils literal notranslate"><span class="pre">virtual=True</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">aslinearoperator</span></code>(left_inds, right_inds[, ...])</p></td>
<td><p>View this <code class="docutils literal notranslate"><span class="pre">TensorNetwork</span></code> as a <code class="xref py py-class docutils literal notranslate"><span class="pre">TNLinearOperator</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code>(dtype[, inplace])</p></td>
<td><p>Convert the type of all tensors in this network to <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype_</span></code>(dtype, *[, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">balance_bonds</span></code>([inplace])</p></td>
<td><p>Apply <code class="xref py py-func docutils literal notranslate"><span class="pre">tensor_balance_bond()</span></code> to all bonds in this tensor network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">balance_bonds_</span></code>(*[, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bond</span></code>(i, j)</p></td>
<td><p>Get the name of the index defining the bond between sites i and j.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bond_size</span></code>(i, j)</p></td>
<td><p>Return the size of the bond between site <code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">bond_sizes</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_current_orthog_center</span></code>()</p></td>
<td><p>Calculate the site(s) of the current orthogonality center.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonize</span></code>(where[, cur_orthog, bra])</p></td>
<td><p>Mixed canonize this TN. If this is a MPS, this implies that::.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonize_around</span></code>(tags[, which, min_distance, ...])</p></td>
<td><p>Expand a locally canonical region around <code class="docutils literal notranslate"><span class="pre">tags</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonize_around_</span></code>(tags[, which, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonize_between</span></code>(tags1, tags2[, absorb])</p></td>
<td><p>'Canonize' the bond between the two single tensors in this network specified by <code class="docutils literal notranslate"><span class="pre">tags1</span></code> and <code class="docutils literal notranslate"><span class="pre">tags2</span></code> using <code class="docutils literal notranslate"><span class="pre">tensor_canonize_bond</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonize_cyclic</span></code>(i[, bra, method, inv_tol])</p></td>
<td><p>Bring this MatrixProductState into (possibly only approximate) canonical form at site(s) <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">check</span></code>()</p></td>
<td><p>Check some basic diagnostics of the tensor network.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">column_reduce</span></code>([output_inds, atol, cache, ...])</p></td>
<td><p>Find bonds on this tensor network which have tensors where all but one column (of the respective index) is non-zero, allowing the 'cutting' of that bond.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">column_reduce_</span></code>([output_inds, atol, cache, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">combine</span></code>(other, *[, virtual, check_collisions])</p></td>
<td><p>Combine this tensor network with another, returning a new tensor network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress</span></code>([form])</p></td>
<td><p>Compress this 1D Tensor Network, possibly into canonical form.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress_all</span></code>([inplace])</p></td>
<td><p>Inplace compress all bonds in this network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress_all_</span></code>(*[, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress_all_1d</span></code>([max_bond, cutoff, ...])</p></td>
<td><p>Compress a tensor network that you know has a 1D topology, this proceeds by generating a spanning 'tree' from around the least central tensor, then optionally canonicalizing all bonds outwards and compressing inwards.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress_all_1d_</span></code>([max_bond, cutoff, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress_all_simple</span></code>([max_bond, cutoff, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress_all_simple_</span></code>([max_bond, cutoff, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress_all_tree</span></code>([inplace])</p></td>
<td><p>Canonically compress this tensor network, assuming it to be a tree.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress_all_tree_</span></code>(*[, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress_between</span></code>(tags1, tags2[, max_bond, ...])</p></td>
<td><p>Compress the bond between the two single tensors in this network specified by <code class="docutils literal notranslate"><span class="pre">tags1</span></code> and <code class="docutils literal notranslate"><span class="pre">tags2</span></code> using <code class="xref py py-func docutils literal notranslate"><span class="pre">tensor_compress_bond()</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress_simplify</span></code>([output_inds, atol, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress_simplify_</span></code>([output_inds, atol, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress_site</span></code>(i[, canonize, cur_orthog, bra])</p></td>
<td><p>Compress the bonds adjacent to site <code class="docutils literal notranslate"><span class="pre">i</span></code>, by default first setting the orthogonality center to that site.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_centralities</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_contracted_inds</span></code>(*tids[, output_inds])</p></td>
<td><p>Get the indices describing the tensor contraction of tensors corresponding to <code class="docutils literal notranslate"><span class="pre">tids</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_hierarchical_grouping</span></code>(max_group_size)</p></td>
<td><p>Group <code class="docutils literal notranslate"><span class="pre">tids</span></code> (by default, all tensors) into groups of size <code class="docutils literal notranslate"><span class="pre">max_group_size</span></code> or less, using a hierarchical clustering.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_hierarchical_linkage</span></code>([tids, method, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_hierarchical_ordering</span></code>([tids, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_hierarchical_ssa_path</span></code>([tids, ...])</p></td>
<td><p>Compute a hierarchical grouping of <code class="docutils literal notranslate"><span class="pre">tids</span></code>, as a <code class="docutils literal notranslate"><span class="pre">ssa_path</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_reduced_factor</span></code>(side, left_inds, ...)</p></td>
<td><p>Compute either the left or right 'reduced factor' of this tensor network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_shortest_distances</span></code>([tids, exclude_inds])</p></td>
<td><p>Compute the minimum graph distances between all or some nodes <code class="docutils literal notranslate"><span class="pre">tids</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code>([mangle_inner, inplace])</p></td>
<td><p>Conjugate all the tensors in this network (leaves all indices).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj_</span></code>([mangle_inner, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract</span></code>([tags, output_inds, optimize, get, ...])</p></td>
<td><p>Contract some, or all, of the tensors in this network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract_</span></code>([tags, output_inds, optimize, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract_around</span></code>(tags[, which, min_distance, ...])</p></td>
<td><p>Perform a compressed contraction inwards towards the tensors identified by <code class="docutils literal notranslate"><span class="pre">tags</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract_around_</span></code>(tags[, which, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract_around_center</span></code>(**opts)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract_around_corner</span></code>(**opts)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract_between</span></code>(tags1, tags2, **contract_opts)</p></td>
<td><p>Contract the two tensors specified by <code class="docutils literal notranslate"><span class="pre">tags1</span></code> and <code class="docutils literal notranslate"><span class="pre">tags2</span></code> respectively.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract_compressed</span></code>(optimize[, output_inds, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract_compressed_</span></code>(optimize[, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract_cumulative</span></code>(tags_seq[, output_inds, ...])</p></td>
<td><p>Cumulative contraction of tensor network.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract_ind</span></code>(ind[, output_inds])</p></td>
<td><p>Contract tensors connected by <code class="docutils literal notranslate"><span class="pre">ind</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract_structured</span></code>(tag_slice[, ...])</p></td>
<td><p>Perform a structured contraction, translating <code class="docutils literal notranslate"><span class="pre">tag_slice</span></code> from a <code class="docutils literal notranslate"><span class="pre">slice</span></code> or <cite>...</cite> to a cumulative sequence of tags.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract_tags</span></code>(tags[, which, output_inds, ...])</p></td>
<td><p>Contract the tensors that match any or all of <code class="docutils literal notranslate"><span class="pre">tags</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract_tags_</span></code>(tags[, which, output_inds, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contraction_cost</span></code>([optimize])</p></td>
<td><p>Compute the 'contraction cost' of this tensor network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contraction_info</span></code>([optimize])</p></td>
<td><p>Compute the <code class="docutils literal notranslate"><span class="pre">opt_einsum.PathInfo</span></code> object decsribing the contraction of this entire tensor network using path optimizer <code class="docutils literal notranslate"><span class="pre">optimize</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contraction_path</span></code>([optimize])</p></td>
<td><p>Compute the contraction path, a sequence of (int, int), for the contraction of this entire tensor network using path optimizer <code class="docutils literal notranslate"><span class="pre">optimize</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contraction_tree</span></code>([optimize, output_inds])</p></td>
<td><p>Return the <code class="xref py py-class docutils literal notranslate"><span class="pre">cotengra.ContractionTree</span></code> corresponding to contracting this entire tensor network with path finder <code class="docutils literal notranslate"><span class="pre">optimize</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contraction_width</span></code>([optimize])</p></td>
<td><p>Compute the 'contraction width' of this tensor network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_to_zero</span></code>()</p></td>
<td><p>Inplace conversion of this network to an all zero tensor network.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code>([virtual, deep])</p></td>
<td><p>Copy this <code class="docutils literal notranslate"><span class="pre">TensorNetwork</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">count_canonized</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cut_between</span></code>(left_tags, right_tags, left_ind, ...)</p></td>
<td><p>Cut the bond between the tensors specified by <code class="docutils literal notranslate"><span class="pre">left_tags</span></code> and <code class="docutils literal notranslate"><span class="pre">right_tags</span></code>, giving them the new inds <code class="docutils literal notranslate"><span class="pre">left_ind</span></code> and <code class="docutils literal notranslate"><span class="pre">right_ind</span></code> respectively.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cut_iter</span></code>(*inds)</p></td>
<td><p>Cut and iterate over one or more indices in this tensor network.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">delete</span></code>(tags[, which])</p></td>
<td><p>Delete any tensors which match all or any of <code class="docutils literal notranslate"><span class="pre">tags</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonal_reduce</span></code>([output_inds, atol, cache, ...])</p></td>
<td><p>Find tensors with diagonal structure and collapse those axes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonal_reduce_</span></code>([output_inds, atol, cache, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance</span></code>(tnB[, xAA, xAB, xBB, method])</p></td>
<td><p>Compute the Frobenius norm distance between two tensor networks:</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">distribute_exponent</span></code>()</p></td>
<td><p>Distribute the exponent <code class="docutils literal notranslate"><span class="pre">p</span></code> of this tensor network (i.e.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code>(other[, compress])</p></td>
<td><p>Act with this MPO on another MPO or MPS, such that the resulting object has the same tensor network structure/indices as <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">draw</span></code>([color, show_inds, show_tags, ...])</p></td>
<td><p>Plot this tensor network as a networkx graph using matplotlib, with edge width corresponding to bond dimension.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">draw_3d</span></code>([color, show_inds, show_tags, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">draw_3d_interactive</span></code>([color, show_inds, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">draw_interactive</span></code>([color, show_inds, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">draw_tree_span</span></code>(tags[, which, min_distance, ...])</p></td>
<td><p>Visualize a generated tree span out of the tensors tagged by <code class="docutils literal notranslate"><span class="pre">tags</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_tags</span></code>([tags])</p></td>
<td><p>Remove a tag or tags from this tensor network, defaulting to all.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">equalize_norms</span></code>([value, inplace])</p></td>
<td><p>Make the Frobenius norm of every tensor in this TN equal without changing the overall value if <code class="docutils literal notranslate"><span class="pre">value=None</span></code>, or set the norm of every tensor to <code class="docutils literal notranslate"><span class="pre">value</span></code> by scalar multiplication only.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">equalize_norms_</span></code>([value, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand_bond_dimension</span></code>(new_bond_dim[, ...])</p></td>
<td><p>Expand the bond dimensions of this 1D tensor network to at least <code class="docutils literal notranslate"><span class="pre">new_bond_dim</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand_bond_dimension_</span></code>(new_bond_dim[, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">filter_valid_site_tags</span></code>(tags)</p></td>
<td><p>Get the valid site tags from <code class="docutils literal notranslate"><span class="pre">tags</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code>(tn_target[, method, tol, inplace, progbar])</p></td>
<td><p>Optimize the entries of this tensor network with respect to a least squares fit of <code class="docutils literal notranslate"><span class="pre">tn_target</span></code> which should have the same outer indices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_</span></code>(tn_target[, method, tol, inplace, progbar])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">flip</span></code>(inds[, inplace])</p></td>
<td><p>Flip the dimension corresponding to indices <code class="docutils literal notranslate"><span class="pre">inds</span></code> on all tensors that share it.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">flip_</span></code>(inds, *[, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_TN</span></code>(tn[, like, inplace])</p></td>
<td><p>Construct a specific tensor network subclass (i.e.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">full_simplify</span></code>([seq, output_inds, atol, ...])</p></td>
<td><p>Perform a series of tensor network 'simplifications' in a loop until there is no more reduction in the number of tensors or indices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">full_simplify_</span></code>([seq, output_inds, atol, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fuse_multibonds</span></code>([gauges, include, exclude, ...])</p></td>
<td><p>Fuse any multi-bonds (more than one index shared by the same pair of tensors) into a single bond.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fuse_multibonds_</span></code>([gauges, include, exclude, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gate_inds</span></code>(G, inds[, contract, tags, info, ...])</p></td>
<td><p>Apply the 'gate' <code class="docutils literal notranslate"><span class="pre">G</span></code> to indices <code class="docutils literal notranslate"><span class="pre">inds</span></code>, propagating them to the outside, as if applying <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">&#64;</span> <span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gate_inds_</span></code>(G, inds[, contract, tags, info, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gate_inds_with_tn</span></code>(inds, gate, ...[, inplace])</p></td>
<td><p>Gate some indices of this tensor network with another tensor network. That is, rewire and then combine them such that the new tensor network has the same outer indices as before, but now includes gate::.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gate_inds_with_tn_</span></code>(inds, gate, ...[, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_all</span></code>([method])</p></td>
<td><p>Gauge all bonds in this network using one of several strategies.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_all_</span></code>([method])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_all_canonize</span></code>([max_iterations, absorb, ...])</p></td>
<td><p>Iterative gauge all the bonds in this tensor network with a basic 'canonization' strategy.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_all_canonize_</span></code>([max_iterations, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_all_random</span></code>([max_iterations, unitary, ...])</p></td>
<td><p>Gauge all the bonds in this network randomly.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_all_random_</span></code>([max_iterations, unitary, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_all_simple</span></code>([max_iterations, tol, ...])</p></td>
<td><p>Iterative gauge all the bonds in this tensor network with a 'simple update' like strategy.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_all_simple_</span></code>([max_iterations, tol, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_local</span></code>(tags[, which, max_distance, ...])</p></td>
<td><p>Iteratively gauge all bonds in the tagged sub tensor network according to one of several strategies.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_local_</span></code>(tags[, which, max_distance, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_simple_insert</span></code>(gauges[, remove, ...])</p></td>
<td><p>Insert the simple update style bond gauges found in <code class="docutils literal notranslate"><span class="pre">gauges</span></code> if they are present in this tensor network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_simple_remove</span></code>([outer, inner])</p></td>
<td><p>Remove the simple update style bond gauges inserted by <code class="docutils literal notranslate"><span class="pre">gauge_simple_insert</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauge_simple_temp</span></code>(gauges[, smudge, ...])</p></td>
<td><p>Context manager that temporarily inserts simple update style bond gauges into this tensor network, before optionally ungauging them.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_loops</span></code>([max_loop_length])</p></td>
<td><p>Generate sequences of tids that represent loops in the TN.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_site_coos</span></code>()</p></td>
<td><p>Generate the coordinates of all possible sites.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_sites_present</span></code>()</p></td>
<td><p>Generate the sites which are currently present (e.g.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_tags_from_coos</span></code>(coos)</p></td>
<td><p>Generate the site tags corresponding to the given coordinates.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">geometry_hash</span></code>([output_inds, strict_index_order])</p></td>
<td><p>A hash of this tensor network's shapes &amp; geometry.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_equation</span></code>([output_inds])</p></td>
<td><p>Get the 'equation' describing this tensor network, in <code class="docutils literal notranslate"><span class="pre">einsum</span></code> style with a single unicode letter per index.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_hyperinds</span></code>([output_inds])</p></td>
<td><p>Get a tuple of all 'hyperinds', defined as those indices which don't appear exactly twice on either the tensors <em>or</em> in the 'outer' (i.e.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_inputs_output_size_dict</span></code>([output_inds])</p></td>
<td><p>Get a tuple of <code class="docutils literal notranslate"><span class="pre">inputs</span></code>, <code class="docutils literal notranslate"><span class="pre">output</span></code> and <code class="docutils literal notranslate"><span class="pre">size_dict</span></code> suitable for e.g.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_multibonds</span></code>([include, exclude])</p></td>
<td><p>Get a dict of 'multibonds' in this tensor network, i.e. groups of two or more indices that appear on exactly the same tensors and thus could be fused, for example.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code>()</p></td>
<td><p>Get a pytree of the 'parameters', i.e. all underlying data arrays.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_symbol_map</span></code>()</p></td>
<td><p>Get the mapping of the current indices to <code class="docutils literal notranslate"><span class="pre">einsum</span></code> style single unicode characters.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_tree_span</span></code>(tids[, min_distance, ...])</p></td>
<td><p>Generate a tree on the tensor network graph, fanning out from the tensors identified by <code class="docutils literal notranslate"><span class="pre">tids</span></code>, up to a maximum of <code class="docutils literal notranslate"><span class="pre">max_distance</span></code> away.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">graph</span></code>([color, show_inds, show_tags, ...])</p></td>
<td><p>Plot this tensor network as a networkx graph using matplotlib, with edge width corresponding to bond dimension.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">graph_tree_span</span></code>(tags[, which, min_distance, ...])</p></td>
<td><p>Visualize a generated tree span out of the tensors tagged by <code class="docutils literal notranslate"><span class="pre">tags</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hyperinds_resolve</span></code>([mode, sorter, ...])</p></td>
<td><p>Convert this into a regular tensor network, where all indices appear at most twice, by inserting COPY tensor or tensor networks for each hyper index.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">hyperinds_resolve_</span></code>([mode, sorter, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">identity</span></code>(**mpo_opts)</p></td>
<td><p>Get a identity matching this MPO.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ind_size</span></code>(ind)</p></td>
<td><p>Find the size of <code class="docutils literal notranslate"><span class="pre">ind</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ind_sizes</span></code>()</p></td>
<td><p>Get dict of each index mapped to its size.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">inds_size</span></code>(inds)</p></td>
<td><p>Return the total size of dimensions corresponding to <code class="docutils literal notranslate"><span class="pre">inds</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">inner_inds</span></code>()</p></td>
<td><p>Tuple of interior indices, assumed to be any indices that appear twice or more (this only holds generally for non-hyper tensor networks).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert_compressor_between_regions</span></code>(ltags, rtags)</p></td>
<td><p>Compute and insert a pair of 'oblique' projection tensors (see for example <a class="reference external" href="https://arxiv.org/abs/1905.02351">https://arxiv.org/abs/1905.02351</a>) that effectively compresses between two regions of the tensor network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert_compressor_between_regions_</span></code>(ltags, rtags)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert_gauge</span></code>(U, where1, where2[, Uinv, tol])</p></td>
<td><p>Insert the gauge transformation <code class="docutils literal notranslate"><span class="pre">U^-1</span> <span class="pre">&#64;</span> <span class="pre">U</span></code> into the bond between the tensors, <code class="docutils literal notranslate"><span class="pre">T1</span></code> and <code class="docutils literal notranslate"><span class="pre">T2</span></code>, defined by <code class="docutils literal notranslate"><span class="pre">where1</span></code> and <code class="docutils literal notranslate"><span class="pre">where2</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert_operator</span></code>(A, where1, where2[, tags, ...])</p></td>
<td><p>Insert an operator on the bond between the specified tensors, e.g..</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert_operator_</span></code>(A, where1, where2[, tags, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">iscomplex</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">isconnected</span></code>()</p></td>
<td><p>Check whether this tensor network is connected, i.e. whether there is a path between any two tensors, (including size 1 indices).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">isel</span></code>(selectors[, inplace])</p></td>
<td><p>Select specific values for some dimensions/indices of this tensor network, thereby removing them.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">isel_</span></code>(selectors, *[, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">isometrize</span></code>([method, allow_no_left_inds, inplace])</p></td>
<td><p>Project every tensor in this network into an isometric form, assuming they have <code class="docutils literal notranslate"><span class="pre">left_inds</span></code> marked.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">isometrize_</span></code>([method, allow_no_left_inds, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">istree</span></code>()</p></td>
<td><p>Check if this tensor network has a tree structure, (treating multibonds as a single edge).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">item</span></code>()</p></td>
<td><p>Return the scalar value of this tensor network, if it is a scalar.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">largest_element</span></code>()</p></td>
<td><p>Return the 'largest element', in terms of absolute magnitude, of this tensor network.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">least_central_tid</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">left_canonize</span></code>([stop, start, normalize, bra])</p></td>
<td><p>Left canonize all or a portion of this TN. If this is a MPS, this implies that::.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">left_canonize_site</span></code>(i[, bra])</p></td>
<td><p>Left canonize this TN's ith site, inplace.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">left_compress</span></code>([start, stop, bra])</p></td>
<td><p>Compress this 1D TN, from left to right, such that it becomes left-canonical (unless <code class="docutils literal notranslate"><span class="pre">absorb</span> <span class="pre">!=</span> <span class="pre">'right'</span></code>).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">left_compress_site</span></code>(i[, bra])</p></td>
<td><p>Left compress this 1D TN's ith site, such that the site is then left unitary with its right bond (possibly) reduced in dimension.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">loop_simplify</span></code>([output_inds, ...])</p></td>
<td><p>Try and simplify this tensor network by identifying loops and checking for low-rank decompositions across groupings of the loops outer indices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">loop_simplify_</span></code>([output_inds, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower_ind</span></code>(site)</p></td>
<td><p>Get the lower physical index name of <code class="docutils literal notranslate"><span class="pre">site</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_norm</span></code>([mangle_append, layer_tags, ...])</p></td>
<td><p>Make the norm tensor network of this tensor network <code class="docutils literal notranslate"><span class="pre">tn.H</span> <span class="pre">&amp;</span> <span class="pre">tn</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_tids_consecutive</span></code>([tid0])</p></td>
<td><p>Reset the <cite>tids</cite> - node identifies - to be consecutive integers.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">mangle_inner_</span></code>([append, which])</p></td>
<td><p>Generate new index names for internal bonds, meaning that when this tensor network is combined with another, there should be no collisions.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_bond</span></code>()</p></td>
<td><p>Return the size of the largest bond in this network.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">maybe_convert_coo</span></code>(x)</p></td>
<td><p>Check if <code class="docutils literal notranslate"><span class="pre">x</span></code> is an integer and convert to the corresponding site tag if so.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">most_central_tid</span></code>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">multiply</span></code>(x[, inplace, spread_over])</p></td>
<td><p>Scalar multiplication of this tensor network with <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">multiply_</span></code>(x, *[, inplace, spread_over])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">multiply_each</span></code>(x[, inplace])</p></td>
<td><p>Scalar multiplication of each tensor in this tensor network with <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">multiply_each_</span></code>(x, *[, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">new_bond</span></code>(tags1, tags2, **opts)</p></td>
<td><p>Inplace addition of a dummmy (size 1) bond between the single tensors specified by by <code class="docutils literal notranslate"><span class="pre">tags1</span></code> and <code class="docutils literal notranslate"><span class="pre">tags2</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code>(**contract_opts)</p></td>
<td><p>Frobenius norm of this tensor network.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outer_dims_inds</span></code>()</p></td>
<td><p>Get the 'outer' pairs of dimension and indices, i.e. as if this tensor network was fully contracted.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outer_inds</span></code>()</p></td>
<td><p>Tuple of exterior indices, assumed to be any lone indices (this only holds generally for non-hyper tensor networks).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outer_size</span></code>()</p></td>
<td><p>Get the total size of the 'outer' indices, i.e. as if this tensor network was fully contracted.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pair_simplify</span></code>([cutoff, output_inds, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pair_simplify_</span></code>([cutoff, output_inds, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">partial_transpose</span></code>(sysa[, inplace])</p></td>
<td><p>Perform the partial transpose on this MPO by swapping the bra and ket indices on sites in <code class="docutils literal notranslate"><span class="pre">sysa</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition</span></code>(tags[, which, inplace])</p></td>
<td><p>Split this TN into two, based on which tensors have any or all of <code class="docutils literal notranslate"><span class="pre">tags</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition_tensors</span></code>(tags[, inplace, which])</p></td>
<td><p>Split this TN into a list of tensors containing any or all of <code class="docutils literal notranslate"><span class="pre">tags</span></code> and a <code class="docutils literal notranslate"><span class="pre">TensorNetwork</span></code> of the the rest.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">permute_arrays</span></code>([shape])</p></td>
<td><p>Permute the indices of each tensor in this MPO to match <code class="docutils literal notranslate"><span class="pre">shape</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pop_tensor</span></code>(tid)</p></td>
<td><p>Remove tensor with <code class="docutils literal notranslate"><span class="pre">tid</span></code> from this network, and return it.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rand_state</span></code>(bond_dim, **mps_opts)</p></td>
<td><p>Get a random vector matching this MPO.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">randomize</span></code>([dtype, seed, inplace])</p></td>
<td><p>Randomize every tensor in this TN - see <code class="xref py py-meth docutils literal notranslate"><span class="pre">quimb.tensor.tensor_core.Tensor.randomize()</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">randomize_</span></code>([dtype, seed, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rank_simplify</span></code>([output_inds, equalize_norms, ...])</p></td>
<td><p>Simplify this tensor network by performing contractions that don't increase the rank of any tensors.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">rank_simplify_</span></code>([output_inds, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce_inds_onto_bond</span></code>(inda, indb[, tags, ...])</p></td>
<td><p>Use QR factorization to 'pull' the indices <code class="docutils literal notranslate"><span class="pre">inda</span></code> and <code class="docutils literal notranslate"><span class="pre">indb</span></code> off of their respective tensors and onto the bond between them.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex</span></code>(index_map[, inplace])</p></td>
<td><p>Rename indices for all tensors in this network, optionally in-place.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex_</span></code>(index_map, *[, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex_lower_sites</span></code>(new_id[, where, inplace])</p></td>
<td><p>Update the lower site index labels to a new string specifier.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex_lower_sites_</span></code>(new_id[, where, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex_upper_sites</span></code>(new_id[, where, inplace])</p></td>
<td><p>Update the upper site index labels to a new string specifier.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex_upper_sites_</span></code>(new_id[, where, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace_section_with_svd</span></code>(start, stop, eps, ...)</p></td>
<td><p>Take a 1D tensor network, and replace a section with a SVD.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace_with_identity</span></code>(where[, which, inplace])</p></td>
<td><p>Replace all tensors marked by <code class="docutils literal notranslate"><span class="pre">where</span></code> with an identity. E.g. if <code class="docutils literal notranslate"><span class="pre">X</span></code> denote <code class="docutils literal notranslate"><span class="pre">where</span></code> tensors::.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace_with_svd</span></code>(where, left_inds, eps, *[, ...])</p></td>
<td><p>Replace all tensors marked by <code class="docutils literal notranslate"><span class="pre">where</span></code> with an iteratively constructed SVD. E.g. if <code class="docutils literal notranslate"><span class="pre">X</span></code> denote <code class="docutils literal notranslate"><span class="pre">where</span></code> tensors::.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace_with_svd_</span></code>(where, left_inds, eps, *)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset_cached_properties</span></code>()</p></td>
<td><p>Reset any cached properties, one should call this when changing the actual geometry of a TN inplace, for example.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">retag</span></code>(tag_map[, inplace])</p></td>
<td><p>Rename tags for all tensors in this network, optionally in-place.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">retag_</span></code>(tag_map, *[, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">retag_all</span></code>(new_id[, inplace])</p></td>
<td><p>Retag all sites and change the <code class="docutils literal notranslate"><span class="pre">site_tag_id</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">retag_all_</span></code>(new_id, *[, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">retag_sites</span></code>(new_id[, where, inplace])</p></td>
<td><p>Modify the site tags for all or some tensors in this tensor network (without changing the <code class="docutils literal notranslate"><span class="pre">site_tag_id</span></code>).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">right_canonize</span></code>([stop, start, normalize, bra])</p></td>
<td><p>Right canonize all or a portion of this TN. If this is a MPS, this implies that::.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">right_canonize_site</span></code>(i[, bra])</p></td>
<td><p>Right canonize this TN's ith site, inplace.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">right_compress</span></code>([start, stop, bra])</p></td>
<td><p>Compress this 1D TN, from right to left, such that it becomes right-canonical (unless <code class="docutils literal notranslate"><span class="pre">absorb</span> <span class="pre">!=</span> <span class="pre">'left'</span></code>).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">right_compress_site</span></code>(i[, bra])</p></td>
<td><p>Right compress this 1D TN's ith site, such that the site is then right unitary with its left bond (possibly) reduced in dimension.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">select</span></code>(tags[, which, virtual])</p></td>
<td><p>Get a TensorNetwork comprising tensors that match all or any of <code class="docutils literal notranslate"><span class="pre">tags</span></code>, inherit the network properties/structure from <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_all</span></code>(tags, *[, which, virtual])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_any</span></code>(tags, *[, which, virtual])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_local</span></code>(tags[, which, max_distance, ...])</p></td>
<td><p>Select a local region of tensors, based on graph distance <code class="docutils literal notranslate"><span class="pre">max_distance</span></code> to any tagged tensors.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_neighbors</span></code>(tags[, which])</p></td>
<td><p>Select any neighbouring tensors to those specified by <code class="docutils literal notranslate"><span class="pre">tags</span></code>.self</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_tensors</span></code>(tags[, which])</p></td>
<td><p>Return the sequence of tensors that match <code class="docutils literal notranslate"><span class="pre">tags</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code>(params)</p></td>
<td><p>Take a pytree of the 'parameters', i.e. all underlying data arrays, as returned by <code class="docutils literal notranslate"><span class="pre">get_params</span></code> and set them.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">shift_orthogonality_center</span></code>(current, new[, bra])</p></td>
<td><p>Move the orthogonality center of this MPS.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code>([max_width])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">singular_values</span></code>(i[, cur_orthog, method])</p></td>
<td><p>Find the singular values associated with the ith bond.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">site_tag</span></code>(i)</p></td>
<td><p>The name of the tag specifiying the tensor at site <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice2sites</span></code>(tag_slice)</p></td>
<td><p>Take a slice object, and work out its implied start, stop and step, taking into account cyclic boundary conditions.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(left_inds[, method, get, absorb, ...])</p></td>
<td><p>Decompose this tensor into two tensors.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_simplify</span></code>([atol, equalize_norms, ...])</p></td>
<td><p>Find tensors which have low rank SVD decompositions across any combination of bonds and perform them.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_simplify_</span></code>([atol, equalize_norms, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_tensor</span></code>(tags, left_inds, **split_opts)</p></td>
<td><p>Split the single tensor uniquely identified by <code class="docutils literal notranslate"><span class="pre">tags</span></code>, adding the resulting tensors from the decomposition back into the network.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#tnpy.operators.MatrixProductOperator.square" title="tnpy.operators.MatrixProductOperator.square"><code class="xref py py-obj docutils literal notranslate"><span class="pre">square</span></code></a>()</p></td>
<td><p>Compute the square of <a class="reference internal" href="#tnpy.operators.MatrixProductOperator" title="tnpy.operators.MatrixProductOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixProductOperator</span></code></a> (MPO), which equivalently merges two MPO layers into one.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code>([fuse, include, exclude, inplace])</p></td>
<td><p>Drop singlet bonds and dimensions from this tensor network.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze_</span></code>([fuse, include, exclude, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">strip_exponent</span></code>(tid_or_tensor[, value])</p></td>
<td><p>Scale the elements of tensor corresponding to <code class="docutils literal notranslate"><span class="pre">tid</span></code> so that the norm of the array is some value, which defaults to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">subgraphs</span></code>([virtual])</p></td>
<td><p>Split this tensor network into disconneceted subgraphs.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum_reduce</span></code>(ind[, inplace])</p></td>
<td><p>Sum over the index <code class="docutils literal notranslate"><span class="pre">ind</span></code> of this tensor network, removing it.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum_reduce_</span></code>(ind, *[, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensors_sorted</span></code>()</p></td>
<td><p>Return a tuple of tensors sorted by their respective tags, such that the tensors of two networks with the same tag structure can be iterated over pairwise.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tids_are_connected</span></code>(tids)</p></td>
<td><p>Check whether nodes <code class="docutils literal notranslate"><span class="pre">tids</span></code> are connected.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dense</span></code>(*inds_seq[, to_qarray])</p></td>
<td><p>Contract this tensor network 'operator' into a dense array.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_qarray</span></code>(*inds_seq[, to_qarray])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code>([left_inds, right_inds])</p></td>
<td><p>Take the trace of this MPO.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unitize</span></code>(**kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unitize_</span></code>(**kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">upper_ind</span></code>(site)</p></td>
<td><p>Get the upper physical index name of <code class="docutils literal notranslate"><span class="pre">site</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">vector_reduce</span></code>(ind, v[, inplace])</p></td>
<td><p>Contract the vector <code class="docutils literal notranslate"><span class="pre">v</span></code> with the index <code class="docutils literal notranslate"><span class="pre">ind</span></code> of this tensor network, removing it.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">vector_reduce_</span></code>(ind, v, *[, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_as</span></code>(cls[, inplace])</p></td>
<td><p>View this tensor network as subclass <code class="docutils literal notranslate"><span class="pre">cls</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_as_</span></code>(cls, *[, inplace])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_like</span></code>(like[, inplace])</p></td>
<td><p>View this tensor network as the same subclass <code class="docutils literal notranslate"><span class="pre">cls</span></code> as <code class="docutils literal notranslate"><span class="pre">like</span></code> inheriting its extra properties as well.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_like_</span></code>(like, *[, inplace])</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">H</span></code></p></td>
<td><p>Conjugate all the tensors in this network (leaves all indices).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">L</span></code></p></td>
<td><p>The number of sites, i.e. length.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">arrays</span></code></p></td>
<td><p>Get the tuple of raw arrays containing all the tensor network data.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></p></td>
<td><p>The dtype of this TensorNetwork, this is the minimal common type of all the tensors data.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower_ind_id</span></code></p></td>
<td><p>The string specifier for the lower phyiscal indices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower_inds</span></code></p></td>
<td><p>Return a tuple of all lower indices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower_inds_present</span></code></p></td>
<td><p>Return a tuple of all lower indices still present in the tensor network.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tnpy.operators.MatrixProductOperator.n_sites" title="tnpy.operators.MatrixProductOperator.n_sites"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_sites</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsites</span></code></p></td>
<td><p>The number of sites.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">num_indices</span></code></p></td>
<td><p>The total number of indices in the tensor network.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">num_tensors</span></code></p></td>
<td><p>The total number of tensors in the tensor network.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#tnpy.operators.MatrixProductOperator.phys_dim" title="tnpy.operators.MatrixProductOperator.phys_dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">phys_dim</span></code></a></p></td>
<td><p>Get the physical dimension of <code class="docutils literal notranslate"><span class="pre">site</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></p></td>
<td><p>Actual, i.e. exterior, shape of this TensorNetwork.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">site_tag_id</span></code></p></td>
<td><p>The string specifier for tagging each site of this tensor network.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">site_tags</span></code></p></td>
<td><p>All of the site tags.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">site_tags_present</span></code></p></td>
<td><p>All of the site tags still present in this tensor network.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sites</span></code></p></td>
<td><p>Tuple of the possible sites in this tensor network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tags</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tensors</span></code></p></td>
<td><p>Get the tuple of tensors in this tensor network.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">upper_ind_id</span></code></p></td>
<td><p>The string specifier for the upper phyiscal indices.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">upper_inds</span></code></p></td>
<td><p>Return a tuple of all upper indices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">upper_inds_present</span></code></p></td>
<td><p>Return a tuple of all upper indices still present in the tensor network.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="id0">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tnpy/operators.html#MatrixProductOperator.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id0" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tnpy.operators.MatrixProductOperator.n_sites">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_sites</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#tnpy.operators.MatrixProductOperator.n_sites" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tnpy.operators.MatrixProductOperator.phys_dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">phys_dim</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#tnpy.operators.MatrixProductOperator.phys_dim" title="Permalink to this definition">#</a></dt>
<dd><p>Get the physical dimension of <code class="docutils literal notranslate"><span class="pre">site</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tnpy.operators.MatrixProductOperator.square">
<span class="sig-name descname"><span class="pre">square</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/tnpy/operators.html#MatrixProductOperator.square"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#tnpy.operators.MatrixProductOperator.square" title="Permalink to this definition">#</a></dt>
<dd><p>Compute the square of <a class="reference internal" href="#tnpy.operators.MatrixProductOperator" title="tnpy.operators.MatrixProductOperator"><code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixProductOperator</span></code></a> (MPO),
which equivalently merges two MPO layers into one.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>squared_mpo</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../operators.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">2. </span>Matrix Product Operator (MPO) &amp; others</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="tnpy.operators.SpinOperators.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">2.2. </span>tnpy.operators.SpinOperators</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Tan Tao-Lin<br/>
  
      &copy; Copyright 2023, Tan Tao-Lin.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>